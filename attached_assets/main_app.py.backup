import sys
import os
import pandas as pd
import numpy as np
from PyQt5.QtWidgets import (QApplication, QMainWindow, QTabWidget, QWidget, QVBoxLayout, 
                            QHBoxLayout, QLabel, QLineEdit, QPushButton, QSpinBox, 
                            QTableWidget, QTableWidgetItem, QFileDialog, QMessageBox, 
                            QProgressBar, QComboBox, QGroupBox, QFormLayout, QDialogButtonBox,
                            QRadioButton, QSlider)
from PyQt5.QtGui import QPixmap, QPainter, QColor, QPen, QBrush, QImage
from PyQt5.QtCore import Qt, QRect, pyqtSignal, QThread, QTimer

from config_manager import ConfigManager
from image_processor import ImageProcessor
from anchor_position_editor import AnchorPositionEditor
from PIL import Image

class SimplePositionSelector(QWidget):
    """
    Упрощенный выбор позиций с помощью радиокнопок и ползунков для отступов.
    """
    position_updated = pyqtSignal(str, str, str)  # (id, x_formula, y_formula)
    
    def __init__(self, config_manager):
        super().__init__()
        self.config_manager = config_manager
        self.initUI()
    
    def initUI(self):
        # Главный горизонтальный лейаут для разделения на управление и визуализацию
        main_layout = QHBoxLayout()
        
        # Левая часть - элементы управления
        left_panel = QVBoxLayout()
        
        # Основной выбор позиции с помощью радиокнопок
        pos_group = QGroupBox("Выберите базовую позицию")
        pos_layout = QHBoxLayout()
        
        # Создаем сетку 3x3 для выбора позиций
        grid_layout = QVBoxLayout()
        
        # Верхний ряд
        top_row = QHBoxLayout()
        self.pos_tl = QRadioButton("Верхний левый")
        self.pos_tc = QRadioButton("Верхний центр")
        self.pos_tr = QRadioButton("Верхний правый")
        top_row.addWidget(self.pos_tl)
        top_row.addWidget(self.pos_tc)
        top_row.addWidget(self.pos_tr)
        grid_layout.addLayout(top_row)
        
        # Средний ряд
        mid_row = QHBoxLayout()
        self.pos_ml = QRadioButton("Средний левый")
        self.pos_mc = QRadioButton("По центру")
        self.pos_mr = QRadioButton("Средний правый")
        mid_row.addWidget(self.pos_ml)
        mid_row.addWidget(self.pos_mc)
        mid_row.addWidget(self.pos_mr)
        grid_layout.addLayout(mid_row)
        
        # Нижний ряд
        bot_row = QHBoxLayout()
        self.pos_bl = QRadioButton("Нижний левый")
        self.pos_bc = QRadioButton("Нижний центр")
        self.pos_br = QRadioButton("Нижний правый")
        bot_row.addWidget(self.pos_bl)
        bot_row.addWidget(self.pos_bc)
        bot_row.addWidget(self.pos_br)
        grid_layout.addLayout(bot_row)
        
        pos_layout.addLayout(grid_layout)
        pos_group.setLayout(pos_layout)
        left_panel.addWidget(pos_group)
        
        # Дополнительные отступы
        offset_group = QGroupBox("Дополнительные отступы")
        offset_layout = QFormLayout()
        
        # Отступ по X
        x_layout = QHBoxLayout()
        self.x_offset_slider = QSlider(Qt.Horizontal)
        self.x_offset_slider.setRange(-200, 200)
        self.x_offset_slider.setValue(0)
        self.x_offset_slider.setTickPosition(QSlider.TicksBelow)
        self.x_offset_slider.setTickInterval(50)
        
        # Спинбокс для точного ввода X-отступа
        self.x_offset_spinbox = QSpinBox()
        self.x_offset_spinbox.setRange(-200, 200)
        self.x_offset_spinbox.setValue(0)
        self.x_offset_spinbox.setSingleStep(1)
        
        # Связываем слайдер и спинбокс
        self.x_offset_slider.valueChanged.connect(self.x_offset_spinbox.setValue)
        self.x_offset_spinbox.valueChanged.connect(self.x_offset_slider.setValue)
        
        x_layout.addWidget(self.x_offset_slider)
        x_layout.addWidget(self.x_offset_spinbox)
        offset_layout.addRow("Отступ по X:", x_layout)
        
        # Отступ по Y
        y_layout = QHBoxLayout()
        self.y_offset_slider = QSlider(Qt.Horizontal)
        self.y_offset_slider.setRange(-200, 200)
        self.y_offset_slider.setValue(0)
        self.y_offset_slider.setTickPosition(QSlider.TicksBelow)
        self.y_offset_slider.setTickInterval(50)
        
        # Спинбокс для точного ввода Y-отступа
        self.y_offset_spinbox = QSpinBox()
        self.y_offset_spinbox.setRange(-200, 200)
        self.y_offset_spinbox.setValue(0)
        self.y_offset_spinbox.setSingleStep(1)
        
        # Связываем слайдер и спинбокс
        self.y_offset_slider.valueChanged.connect(self.y_offset_spinbox.setValue)
        self.y_offset_spinbox.valueChanged.connect(self.y_offset_slider.setValue)
        
        y_layout.addWidget(self.y_offset_slider)
        y_layout.addWidget(self.y_offset_spinbox)
        offset_layout.addRow("Отступ по Y:", y_layout)
        
        offset_group.setLayout(offset_layout)
        left_panel.addWidget(offset_group)
        
        # Выбор сохраненных позиций для редактирования или удаления
        pos_selection_group = QGroupBox("Выберите позицию для редактирования/удаления")
        pos_selection_layout = QVBoxLayout()
        
        self.positions_combo = QComboBox()
        pos_selection_layout.addWidget(self.positions_combo)
        
        # Кнопки для выбранной позиции
        buttons_layout = QHBoxLayout()
        self.load_position_button = QPushButton("Загрузить")
        self.load_position_button.clicked.connect(self.load_selected_position)
        self.delete_position_button = QPushButton("Удалить")
        self.delete_position_button.clicked.connect(self.delete_selected_position)
        
        buttons_layout.addWidget(self.load_position_button)
        buttons_layout.addWidget(self.delete_position_button)
        pos_selection_layout.addLayout(buttons_layout)
        
        pos_selection_group.setLayout(pos_selection_layout)
        left_panel.addWidget(pos_selection_group)
        
        # Обновить список позиций
        self.refresh_positions_list()
        
        # ID позиции и кнопка сохранения
        save_group = QGroupBox("Сохранение позиции")
        save_layout = QHBoxLayout()
        self.position_id_input = QLineEdit()
        save_layout.addWidget(QLabel("ID позиции:"))
        save_layout.addWidget(self.position_id_input)
        
        self.save_button = QPushButton("Сохранить позицию")
        self.save_button.clicked.connect(self.save_position)
        save_layout.addWidget(self.save_button)
        
        save_group.setLayout(save_layout)
        left_panel.addWidget(save_group)
        
        # Добавляем растягивающийся элемент, чтобы прижать элементы к верху
        left_panel.addStretch(1)
        
        # Создаем виджет для левой панели
        left_widget = QWidget()
        left_widget.setLayout(left_panel)
        
        # Добавляем левую панель в основной лейаут
        main_layout.addWidget(left_widget, 2)  # Соотношение 2:1
        
        # Правая часть - предпросмотр позиций
        right_panel = QVBoxLayout()
        
        # Создаем виджет предпросмотра
        self.preview_canvas = QWidget()
        self.preview_canvas.setMinimumSize(300, 500)
        self.preview_canvas.setStyleSheet("background-color: #f0f0f0; border: 1px solid #ccc;")
        
        # Заголовок предпросмотра
        preview_label = QLabel("Предпросмотр выбранной позиции:")
        preview_label.setAlignment(Qt.AlignCenter)
        
        right_panel.addWidget(preview_label)
        right_panel.addWidget(self.preview_canvas)
        
        # Инициализируем первичное отображение без рекурсии
        QTimer.singleShot(100, self._init_preview)
        
        # Добавляем растягивающийся элемент, чтобы прижать элементы к верху
        right_panel.addStretch(1)
        
        # Создаем виджет для правой панели
        right_widget = QWidget()
        right_widget.setLayout(right_panel)
        
        # Добавляем правую панель в основной лейаут
        main_layout.addWidget(right_widget, 1)  # Соотношение 2:1
        
        # Создаем виджет для основного лейаута
        main_widget = QWidget()
        main_widget.setLayout(main_layout)
        
        # Финальный вертикальный лейаут для совместимости с остальным кодом
        layout = QVBoxLayout()
        layout.addWidget(main_widget)
        
        # Соединяем радиокнопки с функцией обновления
        all_radio_buttons = [
            self.pos_tl, self.pos_tc, self.pos_tr,
            self.pos_ml, self.pos_mc, self.pos_mr,
            self.pos_bl, self.pos_bc, self.pos_br
        ]
        for button in all_radio_buttons:
            button.toggled.connect(self.update_preview)
        
        # Соединяем слайдеры с функцией обновления
        self.x_offset_slider.valueChanged.connect(self.update_preview)
        self.y_offset_slider.valueChanged.connect(self.update_preview)
        
        # По умолчанию выбираем центр
        self.pos_mc.setChecked(True)
        
        self.setLayout(layout)
    
    def get_base_formula(self):
        """Получить базовые формулы X и Y в зависимости от выбранной позиции."""
        # Верхний ряд
        if self.pos_tl.isChecked():
            return "MARGIN", "MARGIN"
        elif self.pos_tc.isChecked():
            return "(canvas_width - infografika_width) // 2", "MARGIN"
        elif self.pos_tr.isChecked():
            return "canvas_width - infografika_width - MARGIN", "MARGIN"
        
        # Средний ряд
        elif self.pos_ml.isChecked():
            return "MARGIN", "(canvas_height - infografika_height) // 2"
        elif self.pos_mc.isChecked():
            return "(canvas_width - infografika_width) // 2", "(canvas_height - infografika_height) // 2"
        elif self.pos_mr.isChecked():
            return "canvas_width - infografika_width - MARGIN", "(canvas_height - infografika_height) // 2"
        
        # Нижний ряд
        elif self.pos_bl.isChecked():
            return "MARGIN", "canvas_height - infografika_height - MARGIN"
        elif self.pos_bc.isChecked():
            return "(canvas_width - infografika_width) // 2", "canvas_height - infografika_height - MARGIN"
        elif self.pos_br.isChecked():
            return "canvas_width - infografika_width - MARGIN", "canvas_height - infografika_height - MARGIN"
        
        # По умолчанию - центр
        else:
            return "(canvas_width - infografika_width) // 2", "(canvas_height - infografika_height) // 2"
    
    def refresh_positions_list(self):
        """Обновить список доступных позиций."""
        self.positions_combo.clear()
        positions = self.config_manager.get_positions()
        for pos_id in positions.keys():
            self.positions_combo.addItem(pos_id)
    
    def load_selected_position(self):
        """Загрузить выбранную позицию для редактирования."""
        pos_id = self.positions_combo.currentText()
        if not pos_id:
            QMessageBox.warning(self, "Ошибка", "Выберите позицию из списка")
            return
        
        positions = self.config_manager.get_positions()
        if pos_id not in positions:
            QMessageBox.warning(self, "Ошибка", f"Позиция {pos_id} не найдена")
            return
        
        # Загружаем ID позиции в поле ввода
        self.position_id_input.setText(pos_id)
        
        # Распарсить формулы для определения базовой позиции и отступов
        # Это упрощенный подход, учитывающий только простые случаи
        try:
            x_formula = positions[pos_id]["x"]
            y_formula = positions[pos_id]["y"]
            
            # Устанавливаем центральную позицию по умолчанию
            self.pos_mc.setChecked(True)
            
            # Сброс отступов
            self.x_offset_spinbox.setValue(0)
            self.y_offset_spinbox.setValue(0)
            
            QMessageBox.information(self, "Позиция загружена", 
                                   f"Позиция {pos_id} загружена. Вы можете изменить отступы и сохранить.")
        except Exception as e:
            QMessageBox.warning(self, "Ошибка", f"Не удалось загрузить параметры позиции: {str(e)}")
    
    def delete_selected_position(self):
        """Удалить выбранную позицию."""
        pos_id = self.positions_combo.currentText()
        if not pos_id:
            QMessageBox.warning(self, "Ошибка", "Выберите позицию из списка")
            return
        
        positions = self.config_manager.get_positions()
        if pos_id not in positions:
            QMessageBox.warning(self, "Ошибка", f"Позиция {pos_id} не найдена")
            return
        
        # Подтверждение удаления
        reply = QMessageBox.question(self, "Подтверждение удаления", 
                                    f"Вы действительно хотите удалить позицию {pos_id}?",
                                    QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
        
        if reply == QMessageBox.Yes:
            # Сохраняем ID для обновления позиции перед удалением
            deleted_pos_id = pos_id
            
            # Удаляем позицию
            self.config_manager.delete_position(pos_id)
            QMessageBox.information(self, "Успех", f"Позиция {pos_id} удалена")
            
            # Очищаем поле ввода ID позиции
            self.position_id_input.clear()
            
            # Обновить список позиций
            self.refresh_positions_list()
            
            # Передаем сигнал о том, что позиция удалена с указанием ID
            # Пустые строки для формул означают удаление
            self.position_updated.emit(deleted_pos_id, "", "")
    
    def update_preview(self):
        """Обновить предварительный просмотр формул."""
        x_base, y_base = self.get_base_formula()
        x_offset = self.x_offset_spinbox.value()
        y_offset = self.y_offset_spinbox.value()
        
        # Добавляем отступы к базовым формулам
        if x_offset != 0:
            x_formula = f"({x_base}) + {x_offset}" if x_offset > 0 else f"({x_base}) - {abs(x_offset)}"
        else:
            x_formula = x_base
        
        if y_offset != 0:
            y_formula = f"({y_base}) + {y_offset}" if y_offset > 0 else f"({y_base}) - {abs(y_offset)}"
        else:
            y_formula = y_base
            
        # Если есть превью-канвас в правой панели, то перерисовываем его
        if hasattr(self, 'preview_canvas') and self.preview_canvas:
            self.paint_preview(x_formula, y_formula)
            
        return x_formula, y_formula
        
    def _init_preview(self):
        """Безопасная инициализация предпросмотра без рекурсии"""
        x_base, y_base = self.get_base_formula()
        x_offset = self.x_offset_spinbox.value()
        y_offset = self.y_offset_spinbox.value()
        
        # Добавляем отступы к базовым формулам
        if x_offset != 0:
            x_formula = f"({x_base}) + {x_offset}" if x_offset > 0 else f"({x_base}) - {abs(x_offset)}"
        else:
            x_formula = x_base
        
        if y_offset != 0:
            y_formula = f"({y_base}) + {y_offset}" if y_offset > 0 else f"({y_base}) - {abs(y_offset)}"
        else:
            y_formula = y_base
            
        self.paint_preview(x_formula, y_formula)
            
    def paint_preview(self, x_formula=None, y_formula=None):
        """Рисует предпросмотр на канвасе."""
        if not hasattr(self, 'preview_canvas') or not self.preview_canvas:
            return
            
        # Получаем формулы, если они не переданы
        if x_formula is None or y_formula is None:
            x_base, y_base = self.get_base_formula()
            x_offset = self.x_offset_spinbox.value()
            y_offset = self.y_offset_spinbox.value()
            
            # Добавляем отступы к базовым формулам
            if x_offset != 0:
                x_formula = f"({x_base}) + {x_offset}" if x_offset > 0 else f"({x_base}) - {abs(x_offset)}"
            else:
                x_formula = x_base
            
            if y_offset != 0:
                y_formula = f"({y_base}) + {y_offset}" if y_offset > 0 else f"({y_base}) - {abs(y_offset)}"
            else:
                y_formula = y_base
            
        # Создаем пиксмап для рисования
        pixmap = QPixmap(self.preview_canvas.width(), self.preview_canvas.height())
        pixmap.fill(Qt.white)
        
        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.Antialiasing)
        
        # Получаем настройки
        settings = self.config_manager.get_settings()
        canvas_width = settings.get("canvas_width", 900)
        canvas_height = settings.get("canvas_height", 1200)
        margin = settings.get("margin", 30)
        
        # Масштабируем для отображения
        scale_factor = min(self.preview_canvas.width() / canvas_width, 
                          self.preview_canvas.height() / canvas_height) * 0.9
        display_width = int(canvas_width * scale_factor)
        display_height = int(canvas_height * scale_factor)
        
        # Центрируем отображение
        offset_x = (self.preview_canvas.width() - display_width) // 2
        offset_y = (self.preview_canvas.height() - display_height) // 2
        
        # Рисуем фон холста
        painter.fillRect(offset_x, offset_y, display_width, display_height, QColor(211, 211, 211))
        
        # Рисуем границы отступов
        painter.setPen(QPen(QColor(150, 150, 150), 1))
        margin_scaled = int(margin * scale_factor)
        painter.drawRect(offset_x + margin_scaled, offset_y + margin_scaled, 
                       display_width - 2 * margin_scaled, display_height - 2 * margin_scaled)
        
        # Рисуем центральные линии
        painter.setPen(QPen(QColor(100, 100, 100), 1, Qt.DashLine))
        center_x = offset_x + display_width // 2
        center_y = offset_y + display_height // 2
        painter.drawLine(center_x, offset_y, center_x, offset_y + display_height)
        painter.drawLine(offset_x, center_y, offset_x + display_width, center_y)
        
        # Размер примера инфографики
        sample_width = 300
        sample_height = 300
        sample_width_scaled = int(sample_width * scale_factor)
        sample_height_scaled = int(sample_height * scale_factor)
        
        try:
            # Вычисляем позицию
            context = {
                "canvas_width": canvas_width,
                "canvas_height": canvas_height,
                "infografika_width": sample_width,
                "infografika_height": sample_height,
                "MARGIN": margin
            }
            
            x = eval(x_formula, {"__builtins__": {}}, context)
            y = eval(y_formula, {"__builtins__": {}}, context)
            
            # Масштабируем позицию для отображения
            x_scaled = int(x * scale_factor) + offset_x
            y_scaled = int(y * scale_factor) + offset_y
            
            # Рисуем маркер позиции
            marker_size = 5
            painter.setPen(QPen(Qt.black, 1))
            painter.setBrush(QBrush(Qt.red))
            painter.drawRect(x_scaled - marker_size, y_scaled - marker_size, 
                           marker_size * 2, marker_size * 2)
            
            # Рисуем контур примера инфографики
            painter.setPen(QPen(Qt.blue, 1))
            painter.setBrush(QBrush(QColor(0, 0, 255, 50)))  # Полупрозрачный синий
            painter.drawRect(x_scaled, y_scaled, sample_width_scaled, sample_height_scaled)
            
            # Добавляем описание позиции
            painter.setPen(QPen(Qt.black, 1))
            position_desc = f"X: {x}, Y: {y}"
            painter.drawText(offset_x + 10, offset_y + display_height - 10, position_desc)
            
        except Exception as e:
            painter.setPen(QPen(Qt.red, 1))
            painter.drawText(offset_x + 10, offset_y + 20, f"Ошибка: {str(e)}")
        
        painter.end()
        
        # Отображаем результат на канвасе
        if hasattr(self, '_preview_label'):
            self._preview_label.setPixmap(pixmap)
        else:
            self._preview_label = QLabel(self.preview_canvas)
            self._preview_label.setGeometry(0, 0, self.preview_canvas.width(), self.preview_canvas.height())
            self._preview_label.setPixmap(pixmap)
            self._preview_label.show()
    
    def save_position(self):
        """Сохранить текущую позицию."""
        pos_id = self.position_id_input.text().strip()
        if not pos_id:
            QMessageBox.warning(self, "Ошибка", "Введите ID позиции")
            return
        
        # Получаем формулы напрямую без вызова update_preview
        x_base, y_base = self.get_base_formula()
        x_offset = self.x_offset_spinbox.value()
        y_offset = self.y_offset_spinbox.value()
        
        # Добавляем отступы к базовым формулам
        if x_offset != 0:
            x_formula = f"({x_base}) + {x_offset}" if x_offset > 0 else f"({x_base}) - {abs(x_offset)}"
        else:
            x_formula = x_base
        
        if y_offset != 0:
            y_formula = f"({y_base}) + {y_offset}" if y_offset > 0 else f"({y_base}) - {abs(y_offset)}"
        else:
            y_formula = y_base
            
        self.position_updated.emit(pos_id, x_formula, y_formula)
        
        # Обновляем список позиций после сохранения
        self.refresh_positions_list()

class PositionEditorTab(QWidget):
    """
    Tab for editing position configurations.
    """
    position_updated = pyqtSignal()  # Signal to notify when positions are updated
    
    def __init__(self, config_manager):
        super().__init__()
        self.config_manager = config_manager
        self.initUI()
        
    def initUI(self):
        # Вертикальный лейаут для всего редактора
        layout = QVBoxLayout()
        
        # Вкладки для режимов редактирования и визуализации
        position_tabs = QTabWidget()
        
        # 1. Вкладка "Интуитивный редактор"
        self.anchor_editor = AnchorPositionEditor(self.config_manager)
        self.anchor_editor.position_updated.connect(self.on_position_from_anchor_editor)
        position_tabs.addTab(self.anchor_editor, "Интуитивный редактор")
        
        # 2. Вкладка "Визуализация"
        visualization_widget = QWidget()
        visual_layout = QVBoxLayout()
        
        # Создаем визуализатор позиций
        self.canvas = PositionVisualizer(self.config_manager)
        self.canvas.setMinimumSize(400, 600)  # Увеличиваем размер для лучшей видимости
        visual_layout.addWidget(self.canvas)
        
        # Добавляем кнопку обновления
        self.refresh_visual_button = QPushButton("Обновить визуализацию")
        self.refresh_visual_button.clicked.connect(self.canvas.update)
        visual_layout.addWidget(self.refresh_visual_button)
        
        visualization_widget.setLayout(visual_layout)
        position_tabs.addTab(visualization_widget, "Визуализация")
        
        # 3. Вкладка "Расширенный режим"
        advanced_widget = QWidget()
        advanced_layout = QVBoxLayout()
        
        # Поля ввода для позиции
        edit_group = QGroupBox("Редактировать/Добавить позицию")
        edit_layout = QFormLayout()
        
        self.pos_id_input = QLineEdit()
        self.x_formula_input = QLineEdit()
        self.y_formula_input = QLineEdit()
        
        edit_layout.addRow("ID позиции:", self.pos_id_input)
        edit_layout.addRow("Формула X:", self.x_formula_input)
        edit_layout.addRow("Формула Y:", self.y_formula_input)
        
        button_layout = QHBoxLayout()
        self.save_button = QPushButton("Сохранить")
        self.save_button.clicked.connect(self.save_position)
        self.delete_button = QPushButton("Удалить")
        self.delete_button.clicked.connect(self.delete_position)
        
        button_layout.addWidget(self.save_button)
        button_layout.addWidget(self.delete_button)
        
        edit_layout.addRow(button_layout)
        edit_group.setLayout(edit_layout)
        advanced_layout.addWidget(edit_group)
        
        # Справочный текст
        help_label = QLabel("""
Доступные переменные для формул:
- canvas_width: Ширина холста
- canvas_height: Высота холста
- infografika_width: Ширина инфографики
- infografika_height: Высота инфографики
- MARGIN: Значение отступа из настроек

Примеры:
- Верхний левый угол: MARGIN, MARGIN
- По центру: (canvas_width - infografika_width) // 2, (canvas_height - infografika_height) // 2
- Нижний правый угол: canvas_width - infografika_width - MARGIN, canvas_height - infografika_height - MARGIN
        """)
        advanced_layout.addWidget(help_label)
        
        advanced_widget.setLayout(advanced_layout)
        position_tabs.addTab(advanced_widget, "Расширенный режим")
        
        # Добавляем вкладки в основной лейаут
        layout.addWidget(position_tabs)
        
        # Таблица сохраненных позиций
        table_group = QGroupBox("Сохраненные позиции")
        table_layout = QVBoxLayout()
        
        self.table = QTableWidget()
        self.table.setColumnCount(3)
        self.table.setHorizontalHeaderLabels(["ID позиции", "Формула X", "Формула Y"])
        self.table.setSelectionBehavior(QTableWidget.SelectRows)  # Выделять всю строку
        table_layout.addWidget(self.table)
        
        # Обновляем таблицу
        self.refresh_table()
        
        # Подключаем выбор элементов таблицы к редактору
        self.table.itemSelectionChanged.connect(self.on_position_selected)
        
        table_group.setLayout(table_layout)
        layout.addWidget(table_group)
        
        self.setLayout(layout)
    
    def on_position_from_anchor_editor(self, pos_id, x_formula, y_formula, anchor):
        """Обработать позицию из интуитивного редактора с якорными точками."""
        # Проверяем случай удаления позиции (пустые формулы означают удаление)
        if x_formula == "" and y_formula == "":
            # Это сигнал об удалении позиции
            # Убедимся, что позиция была удалена
            positions = self.config_manager.get_positions()
            if pos_id not in positions:
                # Позиция была успешно удалена, просто обновляем UI
                self.refresh_table()
                self.canvas.update()
                self.position_updated.emit()
                return
            else:
                # Что-то пошло не так, повторно пытаемся удалить
                self.config_manager.delete_position(pos_id)
                QMessageBox.information(self, "Успех", f"Позиция {pos_id} удалена.")
        else:
            # Обычное обновление или добавление позиции с якорем
            positions = self.config_manager.get_positions()
            if pos_id in positions:
                self.config_manager.update_position(pos_id, x_formula, y_formula, anchor)
                QMessageBox.information(self, "Успех", f"Позиция {pos_id} обновлена.")
            else:
                self.config_manager.add_position(pos_id, x_formula, y_formula, anchor)
                QMessageBox.information(self, "Успех", f"Добавлена новая позиция {pos_id}.")
        
        # Refresh UI
        self.refresh_table()
        self.canvas.update()
        self.position_updated.emit()
        
        # Обновить список позиций в редакторе
        self.anchor_editor.refresh_positions_list()
    
    def refresh_table(self):
        """Refresh the positions table with the latest data."""
        positions = self.config_manager.get_positions()
        self.table.setRowCount(len(positions))
        
        for i, (pos_id, pos_config) in enumerate(positions.items()):
            self.table.setItem(i, 0, QTableWidgetItem(pos_id))
            self.table.setItem(i, 1, QTableWidgetItem(pos_config["x"]))
            self.table.setItem(i, 2, QTableWidgetItem(pos_config["y"]))
        
        self.table.resizeColumnsToContents()
    
    def on_position_selected(self):
        """Load the selected position into the editor."""
        selected_items = self.table.selectedItems()
        if not selected_items:
            return
        
        row = selected_items[0].row()
        pos_id = self.table.item(row, 0).text()
        x_formula = self.table.item(row, 1).text()
        y_formula = self.table.item(row, 2).text()
        
        self.pos_id_input.setText(pos_id)
        self.x_formula_input.setText(x_formula)
        self.y_formula_input.setText(y_formula)
    
    def save_position(self):
        """Save or update a position."""
        pos_id = self.pos_id_input.text().strip()
        x_formula = self.x_formula_input.text().strip()
        y_formula = self.y_formula_input.text().strip()
        
        if not pos_id or not x_formula or not y_formula:
            QMessageBox.warning(self, "Ошибка", "Все поля должны быть заполнены.")
            return
        
        # Validate formulas
        try:
            context = {
                "canvas_width": 900,
                "canvas_height": 1200,
                "infografika_width": 300,
                "infografika_height": 300,
                "MARGIN": 30
            }
            eval(x_formula, {"__builtins__": {}}, context)
            eval(y_formula, {"__builtins__": {}}, context)
        except Exception as e:
            QMessageBox.warning(self, "Ошибка", f"Некорректная формула: {str(e)}")
            return
        
        # Save position
        positions = self.config_manager.get_positions()
        if pos_id in positions:
            self.config_manager.update_position(pos_id, x_formula, y_formula)
            QMessageBox.information(self, "Успех", f"Позиция {pos_id} обновлена.")
        else:
            self.config_manager.add_position(pos_id, x_formula, y_formula)
            QMessageBox.information(self, "Успех", f"Добавлена новая позиция {pos_id}.")
        
        # Refresh UI
        self.refresh_table()
        self.canvas.update()
        self.position_updated.emit()
        
        # Clear inputs
        self.pos_id_input.clear()
        self.x_formula_input.clear()
        self.y_formula_input.clear()
    
    def delete_position(self):
        """Delete a position."""
        pos_id = self.pos_id_input.text().strip()
        if not pos_id:
            QMessageBox.warning(self, "Ошибка", "Выберите позицию для удаления.")
            return
        
        positions = self.config_manager.get_positions()
        if pos_id not in positions:
            QMessageBox.warning(self, "Ошибка", f"Позиция {pos_id} не найдена.")
            return
        
        # Confirm deletion
        reply = QMessageBox.question(self, "Подтверждение", 
                                     f"Вы уверены, что хотите удалить позицию {pos_id}?",
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
        if reply == QMessageBox.Yes:
            self.config_manager.delete_position(pos_id)
            QMessageBox.information(self, "Успех", f"Позиция {pos_id} удалена.")
            
            # Refresh UI
            self.refresh_table()
            self.canvas.update()
            self.position_updated.emit()
            
            # Обновить список позиций в редакторе
            self.anchor_editor.refresh_positions_list()
            
            # Clear inputs
            self.pos_id_input.clear()
            self.x_formula_input.clear()
            self.y_formula_input.clear()

class PositionVisualizer(QWidget):
    """
    Widget to visualize position configurations on a canvas.
    """
    def __init__(self, config_manager):
        super().__init__()
        self.config_manager = config_manager
        self.setMinimumSize(300, 400)
        
    def paintEvent(self, event):
        """Paint the canvas with positions."""
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        
        # Get settings
        settings = self.config_manager.get_settings()
        canvas_width = settings.get("canvas_width", 900)
        canvas_height = settings.get("canvas_height", 1200)
        margin = settings.get("margin", 30)
        
        # Scale down for display
        scale_factor = min(self.width() / canvas_width, self.height() / canvas_height) * 0.9
        display_width = int(canvas_width * scale_factor)
        display_height = int(canvas_height * scale_factor)
        
        # Center the display
        offset_x = (self.width() - display_width) // 2
        offset_y = (self.height() - display_height) // 2
        
        # Draw canvas background
        painter.fillRect(offset_x, offset_y, display_width, display_height, QColor(211, 211, 211))
        
        # Draw margin guidelines
        painter.setPen(QPen(QColor(150, 150, 150), 1))
        margin_scaled = int(margin * scale_factor)
        painter.drawRect(offset_x + margin_scaled, offset_y + margin_scaled, 
                         display_width - 2 * margin_scaled, display_height - 2 * margin_scaled)
        
        # Draw center lines
        painter.setPen(QPen(QColor(100, 100, 100), 1, Qt.DashLine))
        center_x = offset_x + display_width // 2
        center_y = offset_y + display_height // 2
        painter.drawLine(center_x, offset_y, center_x, offset_y + display_height)
        painter.drawLine(offset_x, center_y, offset_x + display_width, center_y)
        
        # Sample infographic size
        sample_width = 300
        sample_height = 300
        sample_width_scaled = int(sample_width * scale_factor)
        sample_height_scaled = int(sample_height * scale_factor)
        
        # Draw positions
        positions = self.config_manager.get_positions()
        for pos_id, pos_config in positions.items():
            try:
                # Calculate actual position
                x, y = self.config_manager.calculate_position(
                    pos_id, canvas_width, canvas_height, sample_width, sample_height, margin
                )
                
                # Scale position for display
                x_scaled = int(x * scale_factor) + offset_x
                y_scaled = int(y * scale_factor) + offset_y
                
                # Draw position marker
                marker_size = 5
                painter.setPen(QPen(Qt.black, 1))
                painter.setBrush(QBrush(Qt.red))
                painter.drawRect(x_scaled - marker_size, y_scaled - marker_size, 
                                 marker_size * 2, marker_size * 2)
                
                # Draw sample infographic outline
                painter.setPen(QPen(Qt.blue, 1))
                painter.setBrush(QBrush(Qt.transparent))
                painter.drawRect(x_scaled, y_scaled, sample_width_scaled, sample_height_scaled)
                
                # Draw position ID
                painter.setPen(QPen(Qt.white, 1))
                painter.drawText(x_scaled + 5, y_scaled + 15, pos_id)
            except Exception as e:
                print(f"Ошибка отображения позиции {pos_id}: {e}")
                continue

class PreviewTab(QWidget):
    """
    Tab for previewing infographic positions on images.
    """
    def __init__(self, config_manager):
        super().__init__()
        self.config_manager = config_manager
        self.image_processor = ImageProcessor(config_manager)
        self.initUI()
        
    def initUI(self):
        layout = QVBoxLayout()
        
        # Selector area
        selector_layout = QHBoxLayout()
        
        # Article selection
        article_group = QGroupBox("Выбор артикула и изображения")
        article_layout = QVBoxLayout()
        
        self.article_combo = QComboBox()
        article_layout.addWidget(QLabel("Артикул:"))
        article_layout.addWidget(self.article_combo)
        
        self.image_combo = QComboBox()
        article_layout.addWidget(QLabel("Изображение:"))
        article_layout.addWidget(self.image_combo)
        
        self.refresh_articles_button = QPushButton("Обновить список")
        self.refresh_articles_button.clicked.connect(self.refresh_articles)
        article_layout.addWidget(self.refresh_articles_button)
        
        article_group.setLayout(article_layout)
        selector_layout.addWidget(article_group)
        
        # Infographic selection
        infographic_group = QGroupBox("Выбор инфографики и позиции")
        infographic_layout = QVBoxLayout()
        
        self.infographic_combo = QComboBox()
        infographic_layout.addWidget(QLabel("Инфографика:"))
        infographic_layout.addWidget(self.infographic_combo)
        
        self.position_combo = QComboBox()
        infographic_layout.addWidget(QLabel("Позиция:"))
        infographic_layout.addWidget(self.position_combo)
        
        self.refresh_infographics_button = QPushButton("Обновить список")
        self.refresh_infographics_button.clicked.connect(self.refresh_infographics)
        infographic_layout.addWidget(self.refresh_infographics_button)
        
        infographic_group.setLayout(infographic_layout)
        selector_layout.addWidget(infographic_group)
        
        layout.addLayout(selector_layout)
        
        # Preview button
        self.preview_button = QPushButton("Сгенерировать предпросмотр")
        self.preview_button.clicked.connect(self.generate_preview)
        layout.addWidget(self.preview_button)
        
        # Preview image
        self.preview_label = QLabel()
        self.preview_label.setAlignment(Qt.AlignCenter)
        self.preview_label.setMinimumSize(400, 400)
        self.preview_label.setStyleSheet("background-color: #f0f0f0; border: 1px solid #ccc;")
        layout.addWidget(self.preview_label)
        
        # Connect article selection to image listing
        self.article_combo.currentIndexChanged.connect(self.refresh_images)
        
        # Connect combos to position listing
        self.refresh_positions()
        
        # Initial data population
        self.refresh_articles()
        self.refresh_infographics()
        
        self.setLayout(layout)
    
    def refresh_articles(self):
        """Refresh the list of articles from the photos directory."""
        try:
            self.article_combo.clear()
            
            photos_dir = self.config_manager.get_settings().get("photos_dir", "photos")
            if not os.path.exists(photos_dir):
                QMessageBox.warning(self, "Ошибка", f"Директория фото не найдена: {photos_dir}")
                return
            
            articles = [d for d in os.listdir(photos_dir) if os.path.isdir(os.path.join(photos_dir, d))]
            
            if not articles:
                QMessageBox.information(self, "Информация", "Артикулы не найдены.")
                return
            
            for article in articles:
                self.article_combo.addItem(article)
        except Exception as e:
            QMessageBox.critical(self, "Ошибка", f"Не удалось загрузить список артикулов: {str(e)}")
    
    def refresh_images(self):
        """Refresh the list of images for the selected article."""
        try:
            self.image_combo.clear()
            
            article = self.article_combo.currentText()
            if not article:
                return
            
            photos_dir = self.config_manager.get_settings().get("photos_dir", "photos")
            article_dir = os.path.join(photos_dir, article)
            
            if not os.path.exists(article_dir):
                QMessageBox.warning(self, "Ошибка", f"Директория артикула не найдена: {article_dir}")
                return
            
            allowed_extensions = ['.png', '.jpg', '.jpeg', '.bmp']
            images = [f for f in os.listdir(article_dir) 
                     if os.path.isfile(os.path.join(article_dir, f)) and 
                     f.lower().endswith(tuple(allowed_extensions))]
            
            if not images:
                QMessageBox.information(self, "Информация", "Изображения не найдены.")
                return
            
            for image in images:
                self.image_combo.addItem(image)
        except Exception as e:
            QMessageBox.critical(self, "Ошибка", f"Не удалось загрузить список изображений: {str(e)}")
    
    def refresh_infographics(self):
        """Refresh the list of infographics."""
        try:
            self.infographic_combo.clear()
            
            # Add "None" option first
            self.infographic_combo.addItem("Нет")
            
            infografika_dir = self.config_manager.get_settings().get("infografika_dir", "infografika")
            if not os.path.exists(infografika_dir):
                QMessageBox.warning(self, "Ошибка", f"Директория инфографики не найдена: {infografika_dir}")
                return
            
            infographics = [os.path.splitext(f)[0] for f in os.listdir(infografika_dir) 
                           if f.lower().endswith('.png')]
            
            if not infographics:
                QMessageBox.information(self, "Информация", "Инфографика не найдена.")
                return
            
            for infographic in infographics:
                self.infographic_combo.addItem(infographic)
        except Exception as e:
            QMessageBox.critical(self, "Ошибка", f"Не удалось загрузить список инфографики: {str(e)}")
    
    def refresh_positions(self):
        """Refresh the list of positions."""
        try:
            self.position_combo.clear()
            
            positions = self.config_manager.get_positions()
            if not positions:
                QMessageBox.warning(self, "Ошибка", "Позиции не найдены.")
                return
            
            for pos_id in positions.keys():
                self.position_combo.addItem(pos_id)
        except Exception as e:
            QMessageBox.critical(self, "Ошибка", f"Не удалось загрузить список позиций: {str(e)}")
    
    def generate_preview(self):
        """Generate a preview of the selected image with infographic."""
        try:
            # Get selected values
            article = self.article_combo.currentText()
            image = self.image_combo.currentText()
            infographic = self.infographic_combo.currentText()
            position = self.position_combo.currentText()
            
            if not article or not image:
                QMessageBox.warning(self, "Ошибка", "Выберите артикул и изображение.")
                return
            
            # Get paths
            photos_dir = self.config_manager.get_settings().get("photos_dir", "photos")
            infografika_dir = self.config_manager.get_settings().get("infografika_dir", "infografika")
            photo_path = os.path.join(photos_dir, article, image)
            
            # Get settings
            settings = self.config_manager.get_settings()
            canvas_width = settings.get("canvas_width", 900)
            canvas_height = settings.get("canvas_height", 1200)
            
            # Process image
            canvas = self.image_processor.process_and_center_image(photo_path, canvas_width, canvas_height)
            
            # Add infographic if selected
            if infographic != "Нет":
                infographic_path = os.path.join(infografika_dir, infographic + ".png")
                if os.path.exists(infographic_path):
                    position_id = position
                    canvas = self.image_processor.overlay_infografika(canvas, infographic_path, position_id)
            
            # Convert PIL image to QPixmap for display
            img_data = canvas.convert("RGBA").tobytes("raw", "RGBA")
            qimage = QImage(img_data, canvas.width, canvas.height, QImage.Format_RGBA8888)
            pixmap = QPixmap.fromImage(qimage)
            
            # Scale if necessary to fit the label
            if pixmap.width() > self.preview_label.width() or pixmap.height() > self.preview_label.height():
                pixmap = pixmap.scaled(self.preview_label.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
            
            # Display the preview
            self.preview_label.setPixmap(pixmap)
            
        except Exception as e:
            QMessageBox.critical(self, "Ошибка", f"Не удалось сгенерировать предпросмотр: {str(e)}")

class ProcessImagesThread(QThread):
    """
    Thread for processing images in the background.
    """
    progress_updated = pyqtSignal(int, int)  # (current, total)
    processing_complete = pyqtSignal(int)  # number of processed images
    error_occurred = pyqtSignal(str)  # error message
    
    def __init__(self, config_manager, image_processor):
        super().__init__()
        self.config_manager = config_manager
        self.image_processor = image_processor
        
    def run(self):
        try:
            # Get settings
            settings = self.config_manager.get_settings()
            photos_dir = settings.get("photos_dir", "photos")
            infografika_dir = settings.get("infografika_dir", "infografika")
            excel_file = settings.get("excel_file", "data.xlsx")
            output_dir = settings.get("output_dir", "output")
            canvas_width = settings.get("canvas_width", 900)
            canvas_height = settings.get("canvas_height", 1200)
            margin = settings.get("margin", 30)
            
            # Verify required paths
            if not os.path.exists(photos_dir):
                self.error_occurred.emit(f"Директория фото не найдена: {photos_dir}")
                return
            
            if not os.path.exists(infografika_dir):
                self.error_occurred.emit(f"Директория инфографики не найдена: {infografika_dir}")
                return
            
            if not os.path.exists(excel_file):
                self.error_occurred.emit(f"Excel файл не найден: {excel_file}")
                return
            
            # Read Excel data
            try:
                df = pd.read_excel(excel_file, dtype=str).fillna('')
                data = df.values.tolist()
            except Exception as e:
                self.error_occurred.emit(f"Ошибка чтения Excel файла: {str(e)}")
                return
            
            # Process images
            processed_count = self.image_processor.generate_cards(
                data, photos_dir, infografika_dir, output_dir,
                canvas_width, canvas_height, margin,
                progress_callback=self.progress_updated.emit
            )
            
            self.processing_complete.emit(processed_count)
            
        except Exception as e:
            self.error_occurred.emit(f"Ошибка обработки изображений: {str(e)}")

class ProcessTab(QWidget):
    """
    Tab for processing all images according to Excel data.
    """
    def __init__(self, config_manager):
        super().__init__()
        self.config_manager = config_manager
        self.image_processor = ImageProcessor(config_manager)
        self.initUI()
        
    def initUI(self):
        layout = QVBoxLayout()
        
        # Размеры итогового изображения
        resolution_group = QGroupBox("Размеры итогового изображения")
        resolution_layout = QFormLayout()
        
        settings = self.config_manager.get_settings()
        
        self.canvas_width_input = QSpinBox()
        self.canvas_width_input.setRange(100, 5000)
        self.canvas_width_input.setValue(settings.get("canvas_width", 900))
        self.canvas_width_input.setSingleStep(50)
        self.canvas_width_input.valueChanged.connect(self.update_settings)
        resolution_layout.addRow("Ширина:", self.canvas_width_input)
        
        self.canvas_height_input = QSpinBox()
        self.canvas_height_input.setRange(100, 5000)
        self.canvas_height_input.setValue(settings.get("canvas_height", 1200))
        self.canvas_height_input.setSingleStep(50)
        self.canvas_height_input.valueChanged.connect(self.update_settings)
        resolution_layout.addRow("Высота:", self.canvas_height_input)
        
        preset_layout = QHBoxLayout()
        self.preset_1080p = QPushButton("HD (1920×1080)")
        self.preset_1080p.clicked.connect(lambda: self.set_resolution(1920, 1080))
        self.preset_4k = QPushButton("4K (3840×2160)")
        self.preset_4k.clicked.connect(lambda: self.set_resolution(3840, 2160))
        self.preset_square = QPushButton("Квадрат (1200×1200)")
        self.preset_square.clicked.connect(lambda: self.set_resolution(1200, 1200))
        preset_layout.addWidget(self.preset_1080p)
        preset_layout.addWidget(self.preset_4k)
        preset_layout.addWidget(self.preset_square)
        
        resolution_layout.addRow("Пресеты:", preset_layout)
        resolution_group.setLayout(resolution_layout)
        layout.addWidget(resolution_group)
        
        # Status area
        status_group = QGroupBox("Статус")
        status_layout = QVBoxLayout()
        
        # Check required paths
        photos_dir = settings.get("photos_dir", "photos")
        infografika_dir = settings.get("infografika_dir", "infografika")
        excel_file = settings.get("excel_file", "data.xlsx")
        
        self.status_label = QLabel()
        self.update_status_label(photos_dir, infografika_dir, excel_file)
        status_layout.addWidget(self.status_label)
        
        self.check_button = QPushButton("Проверить статус")
        self.check_button.clicked.connect(lambda: self.update_status_label(photos_dir, infografika_dir, excel_file))
        status_layout.addWidget(self.check_button)
        
        status_group.setLayout(status_layout)
        layout.addWidget(status_group)
        
        # Process button
        self.process_button = QPushButton("Обработать все изображения")
        self.process_button.clicked.connect(self.process_images)
        layout.addWidget(self.process_button)
        
        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)
        layout.addWidget(self.progress_bar)
        
        # Progress label
        self.progress_label = QLabel("Готов к обработке")
        layout.addWidget(self.progress_label)
        
        self.setLayout(layout)
    
    def set_resolution(self, width, height):
        """Установить предустановленное разрешение."""
        self.canvas_width_input.setValue(width)
        self.canvas_height_input.setValue(height)
        self.update_settings()
    
    def update_settings(self):
        """Обновить настройки размеров холста."""
        self.config_manager.update_settings(
            canvas_width=self.canvas_width_input.value(),
            canvas_height=self.canvas_height_input.value()
        )
    
    def update_status_label(self, photos_dir, infografika_dir, excel_file):
        """Update the status label with path checks."""
        status_html = "<ul>"
        
        # Check photos directory
        if os.path.exists(photos_dir):
            articles = [d for d in os.listdir(photos_dir) if os.path.isdir(os.path.join(photos_dir, d))]
            status_html += f"<li>Директория фото: <span style='color:green'>OK</span> ({len(articles)} артикулов)</li>"
        else:
            status_html += f"<li>Директория фото: <span style='color:red'>Не найдена</span></li>"
        
        # Check infographics directory
        if os.path.exists(infografika_dir):
            infographics = [f for f in os.listdir(infografika_dir) if f.lower().endswith('.png')]
            status_html += f"<li>Директория инфографики: <span style='color:green'>OK</span> ({len(infographics)} файлов)</li>"
        else:
            status_html += f"<li>Директория инфографики: <span style='color:red'>Не найдена</span></li>"
        
        # Check Excel file
        if os.path.exists(excel_file):
            try:
                df = pd.read_excel(excel_file)
                status_html += f"<li>Excel файл: <span style='color:green'>OK</span> ({len(df)} строк)</li>"
            except Exception as e:
                status_html += f"<li>Excel файл: <span style='color:red'>Ошибка чтения</span> ({str(e)})</li>"
        else:
            status_html += f"<li>Excel файл: <span style='color:red'>Не найден</span></li>"
        
        status_html += "</ul>"
        self.status_label.setText(status_html)
    
    def process_images(self):
        """Process all images according to Excel data."""
        # Disable UI during processing
        self.process_button.setEnabled(False)
        self.progress_bar.setValue(0)
        self.progress_label.setText("Обработка...")
        
        # Create worker thread
        self.worker = ProcessImagesThread(self.config_manager, self.image_processor)
        self.worker.progress_updated.connect(self.update_progress)
        self.worker.processing_complete.connect(self.processing_complete)
        self.worker.error_occurred.connect(self.processing_error)
        self.worker.start()
    
    def update_progress(self, current, total):
        """Update progress bar."""
        percentage = int((current / total) * 100) if total > 0 else 0
        self.progress_bar.setValue(percentage)
        self.progress_label.setText(f"Обработка артикула {current} из {total}...")
    
    def processing_complete(self, processed_count):
        """Handle processing completion."""
        self.progress_bar.setValue(100)
        self.progress_label.setText(f"Обработка завершена. Обработано {processed_count} изображений.")
        self.process_button.setEnabled(True)
        
        # Show completion message
        settings = self.config_manager.get_settings()
        output_dir = settings.get("output_dir", "output")
        QMessageBox.information(self, "Обработка завершена", 
                                f"Обработано {processed_count} изображений.\n"
                                f"Результаты сохранены в директорию: {output_dir}")
    
    def processing_error(self, error_message):
        """Handle processing error."""
        self.progress_label.setText(f"Ошибка: {error_message}")
        self.process_button.setEnabled(True)
        QMessageBox.critical(self, "Ошибка обработки", error_message)

class SettingsDialog(QWidget):
    """
    Dialog for editing application settings.
    """
    settings_updated = pyqtSignal()  # Signal when settings are updated
    
    def __init__(self, config_manager):
        super().__init__()
        self.config_manager = config_manager
        self.initUI()
        
    def initUI(self):
        self.setWindowTitle("Настройки")
        self.setMinimumWidth(400)
        
        layout = QVBoxLayout()
        
        # Get current settings
        settings = self.config_manager.get_settings()
        
        # Directory settings
        dir_group = QGroupBox("Директории")
        dir_layout = QFormLayout()
        
        self.photos_dir_input = QLineEdit(settings.get("photos_dir", "photos"))
        photos_layout = QHBoxLayout()
        photos_layout.addWidget(self.photos_dir_input)
        browse_photos_button = QPushButton("Обзор...")
        browse_photos_button.clicked.connect(lambda: self.browse_directory(self.photos_dir_input))
        photos_layout.addWidget(browse_photos_button)
        dir_layout.addRow("Директория фото:", photos_layout)
        
        self.infografika_dir_input = QLineEdit(settings.get("infografika_dir", "infografika"))
        infografika_layout = QHBoxLayout()
        infografika_layout.addWidget(self.infografika_dir_input)
        browse_infografika_button = QPushButton("Обзор...")
        browse_infografika_button.clicked.connect(lambda: self.browse_directory(self.infografika_dir_input))
        infografika_layout.addWidget(browse_infografika_button)
        dir_layout.addRow("Директория инфографики:", infografika_layout)
        
        self.output_dir_input = QLineEdit(settings.get("output_dir", "output"))
        output_layout = QHBoxLayout()
        output_layout.addWidget(self.output_dir_input)
        browse_output_button = QPushButton("Обзор...")
        browse_output_button.clicked.connect(lambda: self.browse_directory(self.output_dir_input))
        output_layout.addWidget(browse_output_button)
        dir_layout.addRow("Директория вывода:", output_layout)
        
        self.excel_file_input = QLineEdit(settings.get("excel_file", "data.xlsx"))
        excel_layout = QHBoxLayout()
        excel_layout.addWidget(self.excel_file_input)
        browse_excel_button = QPushButton("Обзор...")
        browse_excel_button.clicked.connect(lambda: self.browse_file(self.excel_file_input, "Excel Files (*.xlsx *.xls)"))
        excel_layout.addWidget(browse_excel_button)
        dir_layout.addRow("Excel файл:", excel_layout)
        
        dir_group.setLayout(dir_layout)
        layout.addWidget(dir_group)
        
        # Canvas settings
        canvas_group = QGroupBox("Параметры холста")
        canvas_layout = QFormLayout()
        
        self.canvas_width_input = QSpinBox()
        self.canvas_width_input.setRange(100, 5000)
        self.canvas_width_input.setValue(settings.get("canvas_width", 900))
        canvas_layout.addRow("Ширина холста:", self.canvas_width_input)
        
        self.canvas_height_input = QSpinBox()
        self.canvas_height_input.setRange(100, 5000)
        self.canvas_height_input.setValue(settings.get("canvas_height", 1200))
        canvas_layout.addRow("Высота холста:", self.canvas_height_input)
        
        self.margin_input = QSpinBox()
        self.margin_input.setRange(0, 500)
        self.margin_input.setValue(settings.get("margin", 30))
        canvas_layout.addRow("Отступ:", self.margin_input)
        
        canvas_group.setLayout(canvas_layout)
        layout.addWidget(canvas_group)
        
        # Buttons
        button_layout = QHBoxLayout()
        save_button = QPushButton("Сохранить")
        save_button.clicked.connect(self.save_settings)
        cancel_button = QPushButton("Отмена")
        cancel_button.clicked.connect(self.close)
        
        button_layout.addWidget(save_button)
        button_layout.addWidget(cancel_button)
        layout.addLayout(button_layout)
        
        self.setLayout(layout)
    
    def browse_directory(self, line_edit):
        """Open a dialog to browse for a directory."""
        directory = QFileDialog.getExistingDirectory(self, "Выбрать директорию", 
                                                     line_edit.text())
        if directory:
            line_edit.setText(directory)
    
    def browse_file(self, line_edit, file_filter):
        """Open a dialog to browse for a file."""
        file_path, _ = QFileDialog.getOpenFileName(self, "Выбрать файл", 
                                                  line_edit.text(),
                                                  file_filter)
        if file_path:
            line_edit.setText(file_path)
    
    def save_settings(self):
        """Save the settings and close the dialog."""
        # Update settings
        self.config_manager.update_settings(
            photos_dir=self.photos_dir_input.text(),
            infografika_dir=self.infografika_dir_input.text(),
            output_dir=self.output_dir_input.text(),
            excel_file=self.excel_file_input.text(),
            canvas_width=self.canvas_width_input.value(),
            canvas_height=self.canvas_height_input.value(),
            margin=self.margin_input.value()
        )
        
        # Emit signal
        self.settings_updated.emit()
        
        # Close the dialog
        self.close()

class MainWindow(QMainWindow):
    """
    Main application window.
    """
    def __init__(self):
        super().__init__()
        self.config_manager = ConfigManager()
        self.initUI()
        
    def initUI(self):
        self.setWindowTitle("Редактор инфографики")
        self.setMinimumSize(800, 600)
        
        # Create central widget with tabs
        self.tabs = QTabWidget()
        
        # Create tabs
        self.position_tab = PositionEditorTab(self.config_manager)
        self.preview_tab = PreviewTab(self.config_manager)
        self.process_tab = ProcessTab(self.config_manager)
        
        # Add tabs to widget
        self.tabs.addTab(self.position_tab, "Редактор позиций")
        self.tabs.addTab(self.preview_tab, "Предпросмотр")
        self.tabs.addTab(self.process_tab, "Обработка изображений")
        
        self.setCentralWidget(self.tabs)
        
        # Create settings dialog
        self.settings_dialog = SettingsDialog(self.config_manager)
        
        # Create menu bar
        menubar = self.menuBar()
        
        # File menu
        file_menu = menubar.addMenu("Файл")
        
        settings_action = file_menu.addAction("Настройки")
        settings_action.triggered.connect(self.open_settings)
        
        file_menu.addSeparator()
        
        exit_action = file_menu.addAction("Выход")
        exit_action.triggered.connect(self.close)
        
        # Help menu
        help_menu = menubar.addMenu("Справка")
        
        about_action = help_menu.addAction("О программе")
        about_action.triggered.connect(self.show_about)
        
        # Connect signals
        self.position_tab.position_updated.connect(self.preview_tab.refresh_positions)
        self.settings_dialog.settings_updated.connect(self.on_settings_updated)
    
    def open_settings(self):
        """Open the settings dialog."""
        self.settings_dialog.show()
    
    def on_settings_updated(self):
        """Handle settings updates."""
        # Update UI components that depend on settings
        self.preview_tab.refresh_articles()
        self.preview_tab.refresh_infographics()
        self.process_tab.update_status_label(
            self.config_manager.get_settings().get("photos_dir", "photos"),
            self.config_manager.get_settings().get("infografika_dir", "infografika"),
            self.config_manager.get_settings().get("excel_file", "data.xlsx")
        )
    
    def show_about(self):
        """Show about dialog."""
        QMessageBox.about(self, "О программе", 
                         "Редактор инфографики\n"
                         "Версия 1.1\n\n"
                         "Программа для размещения инфографики на изображениях\n"
                         "с использованием настраиваемых позиций.")

def main():
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()